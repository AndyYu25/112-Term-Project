Project Description:
The name will be Hydraulic Engineering Simulator.
This term project will be a single-player game where the user controls water flow on a given map using a variety of buildings to protect a city. Buildings will increase/decrease the elevation, or divert water flow.

----------------

Competitive Analysis:

Evaluating my competition:
Cities Skylines is a city-building game primarily revolving around urban planning and controlling the zoning, taxation, services, and infrastructure of a city. 
One of its main features that made this game different from other city-building games is its water simulation. There are multiple buildings which alter water flow, 
including water pumps which draw water from the river, sewage outlets which produce contaminated water, and dams which generate power and reduce the flow of water behind it. 
The game simulates water using a heightfield model, which approximates 3-dimensional water flow as a group of adjacent water columns to reduce the algorithmic complexity.

From Dust is a god video game where the player manipulates materials such as water, lava, and earth to assist a tribe in surviving various challenges. The cursor can move 
large amounts of water as well as manipulate to earth to direct the flow of water. Like Cities Skylines, From Dust uses a heightfield to simulate water flow, but it has the 
additional feature of implementing erosion, where moving water can quickly erode the terrain.

Sea of Thieves is an action-adventure video game where a group of players explore an open world on a pirate ship. Water is used primarily in interactions ships, such as 
when a wave collides with a ship or when a ship takes damage and water flows in. The game simulates water by using a Fast Fourier Transform to generate vector fields for the water.

Comparison Dimensions:

	The first dimension is how well the program models and displays fluid dynamics for water (water accuracy). Given that the common factor between all three games is that they 
implement a physics engine, the most important dimension is how accurately the program models water flow.

	Usability is how easy it is for an inexperienced user to play the game. The ability to easily use a program is important, because that directly correlates with a good 
experience for the user and the ability to access all features available in the program.
	Appearance is how well the water simulation looks. Given that these programs all simulate water, how they render that simulation also plays a part in how convincing is the 
physics engine to the user. 
	Water Control is how well the user can control water flow through use of buildings and tools. Although the realism and ease of use of the program are more important factors, 
the ability for users to easily change water flow is important in determining the significance of 
	Significance is how important water mechanics are to the program. As the project primarily revolves around water, determining how important fluid dynamics are to the program 
should be evaluated when comparing these three programs.

Comparison Table:

Key: 
W Acc: Water Accuracy
U: Usability
W App: Water Appearance
C: Water Control
S: Significance


				W	U	W	W
				Acc		App	C	S
Cities Skylines		3	4	3	4	3
From Dust			4	4	4	2	3
Sea of Thieves		3	5	5	1	2

Summary:
	The main gap left between all three games involving a realistic fluid model is the importance that water has in the game. Water is mainly a secondary feature in all the mentioned 
games, and two of the games do not have many game mechanics to control water flow, so the term project needs to stand out in terms of how water is used in the game. The project will also 
need to have an intuitive user interface and game mechanics and reasonably model water flow well enough to compete with the other games. 

----------------

Structural Plan:

Algorithm File:
	function isLocalMin(hexGrid.getElevationGraph, row, col)
	function dijkstraAll(hexGrid.getElevationGraph, row, col)
	function dijkstraPath(hexGrid.getElevationGraph, startNode, endNode)
	function findClosestMin(hexGrid.getElevationGraph)
		
Hexagonal grid file:
	object hexGrid
		attribute rows: int 
		attribute cols: int
		attribute grid: 2D list of hex objects
		attribute capitalCoords: tuple of ints
		function generateHexes(rows, cols)
		function getElevationGraph(grid)
		function getNodes(rows, cols)
	object hexTile
		attribute row:int
		attribute col:int
		attribute building: building object (or any other object inheriting from building
		attribute landElevation: float
		attribute buildingElevation: float
		attribute waterElevation: float
		attribute totalElevaton: float
		attribute hexGrid: hexGrid object
		attribute adjacentHexes: list of tuples
		attribute isSourceBlock: boolean
		attribute flowVector: dictionary
		function setflowVector(row, col, hexGrid.getElevationGraph())
		function getInfo()
			returns row, col, building
		function setAdjacentHexes(hexGrid.rows, hexGrid.cols)
		function updateTile(waterElevationChange, landElevationChange)
		function render()
		function renderFlowVector(flowVector)

Building file:
	object building:
		attribute cost: int
		attribute name: string
		attribute row: int
		attribute col: int
		attribute cost: int
		function getInfo()
	object levee inherits from building
		function increaseBuildingHeightBy1()
		function render
	object ditch inherits from building
		function decreaseBuildingHeightBy1()
		function render
	object capital inherits from building
		function render
	object dam inherits from building
		attribute startRow: int
		attribute endRow: int
		attribute startCol: int
		attribute endCol: int
		attribute damDirection: tuple of ints
		attribute inFlowPosition: tuple of ints
		function increaseBuildingHeightBy1()
		function render

__init__ File:
	ModalApp hydroGame
	Mode startMode:
		function keyPressed
		function redrawAll
	Mode gameMode:
		attribute selectedNode: tuple
		attribute board: hexGrid
		attribute timeSurvived: int
		attribute timer: int
		attribute resources: int
		attribute displayTile: tuple
		attribute hexSize: int
		function mousePressed()
		function mouseMoved()
		function keyPressed()
		function timerFired()
		function redrawAll()

	
	Mode endMode:
		attribute timeSurvived: int
		function keyPressed
		function redrawAll

----------------

Algorithmic Plan: 
Plan for hexGrid.getElevationGraph():
	For each node, calculate the edge weight to each adjacent node using this formula:
		edge weight = (sin(arctan(toNodeHeight - fromNodeHeight)) + 1)
		Formula normalizes the height difference between 0 and 2 to avoid negative edge weights. Lower value means a less steep slope
	return an adjacency list (using a dictionary) with each entry containing a list of outgoing edges defined by a tuple with the destination node and the edge weight.
	Nodes are represented by a tuple containing the row and column of the corresponding cell.

Plan for hexGrid.getNodes(rows, cols):
	Return a set of vertex IDs by iterating through hexGrid.rows and hexGrid.cols to get a set containg all possible node IDs.

Plan for function dijkstraAll(hexGrid.getElevationGraph(), row, col):
	Based off of https://docs.google.com/presentation/d/1PrMI2N50vFuaUetykBXcZyYIa-q-vgJvd3MvO7rDRQQ/edit?usp=sharing and https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e#:~:text=Dijkstra's%20algorithm%20can%20be%20used,to%20find%20the%20shortest%20path.	

	Create an set unvisited equal to hexGrid.getNodes(), and  two empty dictionaries: nodeValues and previousVertices
	iterate through each node in hexGrid.getNodes:
		populate nodeValues with node as the key and positive infinity as the value.
	set the initial node value (given by the row, col inputs) to 0
	loop while unvisited is not empty:
		set current node to be the node with the lowest value in nodeValues.
		remove node from unvisited
		loop through hexGrid.getElevationGraph()[current node] (loop through all neighbors):
			if the current node value + the edge weight is less than the node value of the neighbor, set the nodeValue to be that sum and set previousVertices[neighboring node] to be the current node
	return nodeValues (which gives the minimum cost to travel from the initial node to the current node)
		
Plan for function dijsktraPath(hexGrid.getElevationGraph(), initial node, destination node)
	Similar to dijkstraAll and based off of https://docs.google.com/presentation/d/1PrMI2N50vFuaUetykBXcZyYIa-q-vgJvd3MvO7rDRQQ/edit?usp=sharing	
	Create an set unvisited equal to hexGrid.getNodes(), and  two empty dictionaries: nodeValues and previousVertices
	iterate through each node in hexGrid.getNodes:
		populate nodeValues with node as the key and positive infinity as the value.
	set the initial node value (given by the row, col inputs) to 0
	loop while unvisited is not empty:
		set current node to be the node with the lowest value in nodeValues.
		remove node from unvisited		
		break if current node is equal to destination node
	create an empty list path
	use previousVertices to add the shortest path starting with the destination to the start node and ending at the initial node
	return path and nodeValues[destination node]
	
		
Plan for findClosestMin(hexGrid.getElevationGraph, row, col):
	Use DijkstraAll function to get the shortest paths from the given node to all other nodes.
	Iterate through the returned nodeValues.
		Check if the node is a local minimum by checking if all the edge weights of edges originating from the node are greater or equal to 1.
	return the local minima which have the least distance.


Plan for setFlowVectors(row, col):
	row and col correspond to the given node
	get closest local minima using findClosestMin.
	create 2 empty dictionaries: output and adjacentCost
	loop through each adjacent tile/node:
		get the cost of the shortest path from the adjacent tile to the local minima with dijsktraPath.
		add an entry in adjacentCost with the adjacent tile ID as the key and the cost as the value.
	get the sum of the all costs in adjacentCost 
	loop through keys in adjacentCost:
		add an entry in output with the given key as the key and the cost divided by the sum as the value.
	return output dictionary


----------------
	
Timeline Plan: 
Sunday: finish design proposal
Monday:	finish hex board render and hexagonal grid file, basic buildings, algorithm, and get basic UI with the modes in __init__(basic clicks/keypresses for most game mechanics)
Tuesday: possibly add more buildings such as dams, flesh out modes and controls, finish building file
Wednesday: continue Tuesday work, finish __init__ file
Thursday: work on implementing isometric projection, add readme, create video demo

----------------

Version Control: 
I will use AOMEI Backupper, a free backup software to regularly back up term project folder into a SD card at 1-hour intervals every day. 
In addition, the term project folder will be stored in my documents folder, which is regularly synced to OneDrive.

----------------
TP2 Update:
Reworked the dam building:
New Dam Building structure
	object dam inherits from building
		attribute height: int
		attribute cost: int
		attribute damIntake: tuple (coordinates)
		attribute damOutput: tuple (coordinates)
		function render

Modified gameMode:
		removed function buyBuilding(selectedNode, board, resources, buildingType: string)
		moved function updateWater(board) to hexGrid object

Added renderVectorArrow(x1, y1, angle, length, thickness, arrowheadSize, hexRadius), drawHexagon(radius, cx, cy, color, outline) as helper functions to hexgrid.py

TP3 Update:
Added an instruction, start, and end mode.
Added isometric view for single hex and the entire grid (grid view goes off canvas)
Added savegame and loadgame features and a scoreboard.
Added a new file, isometric.py, which contains all the functions for isometric viewing.
Added several new methods to __init__.gamemode and hexgrid.hexTile for isometric viewing purposes